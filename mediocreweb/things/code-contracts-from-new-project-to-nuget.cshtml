@inherits ServiceStack.Razor.ViewPage
<link rel="stylesheet" type="text/css" href="@Url.Content("~/css/sh/shCore.css")"/>
<link rel="stylesheet" type="text/css" href="@Url.Content("~/css/sh/shThemeVS2012Light.css")"/>
<link rel="stylesheet" type="text/css" href="@Url.Content("~/css/sh/scrollbarHack.css")"/>
<style type="text/css">
  .how-i-do-it {
    position: relative;
    padding-top: 40px;
  }
  .how-i-do-it:after {
    content: "How I do it:";
    position: absolute;
    top: 15px;
    color: #888;
  }
</style>
<div class="row">
  <div class="col-md-3">
    <nav class="pagenav visible-md visible-lg" id="pagenav">
      <ul class="nav">
        <li>nav</li>
      </ul>
    </nav>
  </div>
  <div class="col-md-9">

    <h2 id="cc-intro">Introduction</h2>

    <p>
      Code Contracts is Microsoft's implementation of <a href="https://en.wikipedia.org/wiki/Design_by_contract">Design by Contract</a>
      for VB and C#. Using the <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts(v=vs.110).aspx">System.Diagnostics.Contracts Namespace</a>
      included with .NET 4.0 and the <a href="http://research.microsoft.com/en-us/projects/contracts/">Code Contracts</a> tools you can further
      define the behavior of your software and verify it at compile time as well as run time.
      I don't see Code Contracts as yet another test framework and I don't see Design by Contract as a replacement for testing.
      For me Code Contracts helps to set boundaries, compartmentalize problems, and better focus on writing meaningful code by increasing trust.
    </p>

    TODO: more DBC explanations
    TODO: examples

    <h2>Getting Started</h2>
    <h3>What You Need</h3>

    <ul>
      <li>Visual Studio Pro or better</li>
      <li>.NET 4.0</li>
      <li><a href="http://research.microsoft.com/en-us/projects/contracts/">Code Contracts</a></li>
    </ul>
    <p>
      You can't install the tools in an Express Edition of Visual Studio because it includes a Visual Studio extension.
      There may be ways to work around that but you will have to look into that yourself.
      I have used the tools in 2010 and 2012 but no longer have access to up to date Microsoft software so I can't confirm 2013 compatibility.
      Be aware though that this only applies to the tooling. The Contracts namespace is part of .NET 4.0 so if you use it as I do
      you shouldn't be left with a code base that won't compile/run if you have to downgrade to express.
    </p>

    <h3>Build Configurations</h3>

    <p>
      By default your projects will have a Debug and Release configuration.
      The debug build can be used for development and testing while the release build is what you would likely run in production or distribute to others.
      While you can use Code Contracts with these two configurations I find it inconvenient.
      When I work with a debug build I like to run the application and tests frequently and quickly but the Code Contracts tooling gets in the way of this.
      My solution is to have three configurations by adding a DebugCC configuration.
      Each of the three configurations has different settings with respect to Code Contracts.
    </p>
    <dl>
      <dt>Debug</dt>
      <dd>
        The primary configuration is the standard Debug configuration which has no additional build steps related to Code Contracts and is for standard development and testing.
      </dd>
      <dt>Release</dt>
      <dd>
        This is the standard Release configuration but with one minor addition in the case of a library.
        While Code Contracts tooling is not run on the resulting assembly a second contract assembly can be produced for distribution.
      </dd>
      <dt>DebugCC</dt>
      <dd>
        The DebugCC configuration is based on the Debug configuration but has Code Contracts tooling enabled.
        I periodically build and test with this configuration, often as I get close to a stopping point.
      </dd>
    </dl>

    <div class="well how-i-do-it">
      Create the extra configuration for the <em>solution</em>:
      <ol>
        <li>Within Visual Studio navigate to <span class="label label-primary">Build</span> &darr; <span class="label label-primary">Configuration Manager...</span>
          (or <span class="label label-default">ALT</span>+<span class="label label-default">B</span>+<span class="label label-default">O</span>).
        </li>
        <li>Select the <span class="label label-primary">&lt;New...&gt;</span> item from the <b>Active solution configuration</b> drop down.</li>
        <li>Enter <b>DebugCC</b> in the <b>Name</b> field.</li>
        <li>Copy settings from <b>Debug</b>.</li>
        <li>Check the <b>Create new project configurations</b> check box if no projects have this configuration yet (none should).</li>
        <li>Click <span class="label label-default">OK</span>.</li>
      </ol>
      Create the extra configuration for <em>projects added later</em>:
      <ol>
        <li>Within Visual Studio navigate to <span class="label label-primary">Build</span> &darr; <span class="label label-primary">Configuration Manager...</span>
          (or <span class="label label-default">ALT</span>+<span class="label label-default">B</span>+<span class="label label-default">O</span>).
        </li>
        <li>Select the <span class="label label-primary">DebugCC</span> item from the <b>Active solution configuration</b> drop down.</li>
        <li>Click on the configuration for projects that do not have a <b>DebugCC</b> configuration associated and select <span class="label label-primary">&lt;New...&gt;</span>.</li>
        <li>Enter <b>DebugCC</b> in the <b>Name</b> field.</li>
        <li>Copy settings from <b>Debug</b>.</li>
        <li>Click <span class="label label-default">OK</span>.</li>
      </ol>
    </div>

    <p>
      You have to configure Code Contracts for each project that you want to use it for.
      I configure each of the three configurations differently.
      I will explain later some of the reasons for these different configurations but for now this should get you started.
    </p>

    <div class="well how-i-do-it">
      Access the Code Contracts project property sheet.
      <ol>
        <li>Install Code Contracts if you have not already.</li>
        <li>Right click on a project and select <span class="label label-primary">Properties</span> from the context menu
          (or <span class="label label-default">ALT</span>+<span class="label label-default">Enter</span>).</li>
        <li>Select the tab on the left for <b>Code Contracts</b>.</li>
      </ol>
    </div>

    <div class="row">
      <div class="col-md-4">
        <h4>DebugCC</h4>
        <a href="@Url.Content("~/things/garbage-file/cc-assets/prjcfg-debugcc.png")" target="_blank">
          <img
            src="@Url.Content("~/things/garbage-file/cc-assets/prjcfg-debugcc.png")"
            alt="DebugCC project configuration screen shot"
            class="img-responsive" />
        </a>
        <p><small>DebugCC builds are where I use the Code Contracts tools.</small></p>
        <ol class="list-unstyled">
          <li><small><b>Assembly Mode</b> should be left on Custom Parameter Validation.</small></li>
          <li><small><b>Perform Runtime Contract Checking</b> is enabled and set to Full.</small></li>
          <li><small><b>Perform Static Contract Checking</b> is enabled.</small></li>
          <li><small><b>SQL Server</b> cache is configured to use my SQL Express instance on <code>.\SQLEXPRESS</code>.</small></li>
          <li><small><b>Warning Level</b> can be turned up a notch or two if you want.</small></li>
          <li><small><b>Contract Reference Assembly</b> is set to Build and also enable &quot;Emit contracts into XML doc file.&quot;</small></li>
        </ol>
      </div>
      <div class="col-md-4">
        <h4>Release</h4>
        <a href="@Url.Content("~/things/garbage-file/cc-assets/prjcfg-release.png")" target="_blank">
          <img
            src="@Url.Content("~/things/garbage-file/cc-assets/prjcfg-release.png")"
            alt="Release project configuration screen shot"
            class="img-responsive" />
        </a>
        <small>
          For release builds I only configure it to &quot;Build&quot; the Contract Reference Assembly and to &quot;Emit contracts into XML doc file.&quot;
          This allows contracts to be distributed along side my released assemblies instead of modifying my resulting assemblies.
        </small>
      </div>
      <div class="col-md-4">
        <h4>Debug</h4>
        <a href="@Url.Content("~/things/garbage-file/cc-assets/prjcfg-debug.png")" target="_blank">
          <img
            src="@Url.Content("~/things/garbage-file/cc-assets/prjcfg-debug.png")"
            alt="Debug project configuration screen shot"
            class="img-responsive" />
        </a>
        <small>
          I leave the Debug configuration alone so that it has Code Contracts post-build actions disabled.
          This also leaves my assemblies untouched to simplify debugging.
        </small>
      </div>
    </div>
    
    <h2>Writing Contracts</h2>

    <h3>Method Anatomy with Code Contracts</h3>
    TODO!

    <h3>Preconditions</h3>
    <p>
      As preconditions are to be checked before a method performs its real work they are the first statements within the contract block of a method.
      Preconditions can be written in two forms:
    </p>
    <dl>
      <dt>&quot;legacy&quot; requires (standard preconditions)</dt>
      <dd>
        <p>
          The &quot;legacy&quot; requires are my main choice when writing precondtions and you probably already have plenty in your existing source.
          These preconditions are written using a basic <code class="brush: csharp;">if( ! precondition) throw new SpecificException();</code> statement
          and must be the first preconditions in the contract block.
          I suppose the name would make sense if code contracts were built into the language but they are not so I don't feel the name is appropriate.
          I will refer to them as <em>standard preconditions</em> from now on.
          Note that when using standard preconditions without any other calls to Contract.Requires or Contract.Ensures a call to
          <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.contract.endcontractblock(v=vs.110).aspx">Contract.EndContractBlock</a>
          is required to complete the contract block.
        </p>
      </dd>
      <dt>Contract.Requires</dt>
      <dd>
        <p>
          The <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.contract.requires(v=vs.110).aspx">Contract.Requires</a> methods
          are another way to specify preconditions. They act similar to an assertion exept they are only compiled into my programs when using the DebugCC configuration.
          While this seems pointless it has its uses.
          This approach supplies the Code Contracts static analysis tools with information but can be ommited from the software in release builds.
          Also note that while Contract.Requires does have a generic option available I do <em><u><strong>not</strong></u></em> use it.
          The generic versions require a post build step to run correctly while standard preconditions work just fine.
        </p>
      </dd>
    </dl>
      
    <h4>When to Choose Standard Preconditions</h4>
    <p>
      When a method is publicly accessible (public or protected) from outside an assembly I use the standard method of specifying preconditions as shown in the following example.
    </p>
    <pre class="brush: csharp;">[Pure]
public static bool IsTrimmed(string text) {
    if (text == null)
        return false;
    if (text.Length == 0)
        return true;
    if (Char.IsWhiteSpace(text[0]))
        return false;
    return text.Length == 1 || !Char.IsWhiteSpace(text[text.Length - 1]);
}

public static string WordTitleCase(string input) {
    if (String.IsNullOrEmpty(input))
        throw new ArgumentException("Must not be null or empty.", "input");
    if (!IsTrimmed(input))
        throw new ArgumentException("Must be trimmed.", "input");
    Contract.EndContractBlock();
    var builder = new System.Text.StringBuilder(input.Length);
    builder.Append(Char.ToUpper(input[0]));
    for (int i = 1; i < input.Length; i++)
        builder.Append(Char.ToLower(input[i]));
    return builder.ToString();
}</pre>
    <p>
      Using the standard form ensures that my checks are present in every build even if Code Contracts tools are not used.
    </p>
    
    <h4>When to Choose Contract.Requires</h4>
    <p>
      When a method is not publicly accessible (private or internal) I tend to use the Contract.Requires form as in the following example.
    </p>
    <pre class="brush: csharp">internal static T QuickFirstOrDefault&lt;T&gt;(this T[] array) {
    Contract.Requires(array != null);
    return array.Length == 0 ? default(T) : array[0];
}</pre>
    <p>
      I also use Contract.Requires when a precondition is redundant which can be common in situations involving inheritance.
      This provides the Code Contracts tools with important information and prevents needless checks at runtime.
    </p>
    <div class="row">
      <div class="col-md-6">
        Redundant preconditions:
        <pre class="brush: csharp">public class WithNewLines : Base {
    public WithNewLines(string value)
        : base(value) { // enforced in here
        Contract.Requires(value != null);
    }
    public override void Append(string text) {
        // inherits preconditions automatically
        base.Append(text); // enforced in here
        Value += Environment.NewLine;
    }
    public void AppendRaw(string text) {
        Contract.Requires(text != null);
        base.Append(text); // enforced in here
    }
}</pre>
        <div class="alert alert-info">
          <strong>Note:</strong> Inheritance is hard!
        </div>
      </div>
      <div class="col-md-6">
        Orignal preconditions:
        <pre class="brush: csharp">public class Base {
    public string Value { get; set; }
    public Base(string value) {
        if (value == null)
            throw new ArgumentNullException();
        Contract.EndContractBlock();
        Value = value;
    }
    public virtual void Append(string text) {
        Contract.Requires(text != null);
        Contract.EndContractBlock(); // a hint
        // not a part of the contract block
        //  but will be in all builds to enforce
        // must be seperate because I am using
        //  Custom Parameter Validation
        //  and a concrete implementation
        if (text == null)
            throw new ArgumentNullException();
        Value += text;
    }
}</pre>
      </div>
    </div>
    <h3>Postconditions</h3>

    <p>
      Postconditions allow us to specify conditions that should hold when exiting a method.
      Because there are different ways to exit a method there are also different ways to specify postconditions.
    </p>

    <dl>
      <dt>Contract.Ensures</dt>
      <dd>
        <p>
          The <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.contract.ensures(v=vs.110).aspx">Contract.Ensures</a> methods
          allow the specification of postconditions that hold when a method returns a value or when a void method executes its last statement.
          I most often use these to describe a value that is returned (<a href="http://msdn.microsoft.com/en-us/library/dd412873(v=vs.110).aspx">Contract.Result</a>)
          but they can also describe object state.
        </p>
      </dd>
      <dt>Contract.EnsuresOnThrow</dt>
      <dd>
        <p>
          Postconditions can also be made for exceptional method termination using the
          <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.contract.ensuresonthrow(v=vs.110).aspx">Contract.EnsuresOnThrow</a> methods.
          These generic methods are similar to Contract.Ensures but also require a generic argument that specifies the exception type they apply to.
          These postconditions are very important when writing exception safe code.
        </p>
      </dd>
    </dl>

    <h4>Examples</h4>

    TODO: on throw

    <h3>Invariants</h3>

    <h2>Purity</h2>

    <h2>Static Analysis</h2>

    <h2>Assume and Assert</h2>

    <h2>Conditional Contracts</h2>

    <h2>Inheritance</h2>

    <h2>Distribution</h2>

    <h3>Using Contracts</h3>

    <h3>NuGet</h3>
    
    <h3>Signing</h3>

    <h2>Final Thoughts</h2>

  </div>
</div>

<script type="text/javascript" src="@Url.Content("~/js/sh/shCore.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushCSharp.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushCss.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushDiff.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushJScript.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushPlain.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushPowerShell.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushSql.js")"></script>
<script type="text/javascript" src="@Url.Content("~/js/sh/shBrushXml.js")"></script>
<script type="text/javascript">
  $(function () {
    var body = $(document.body);
    body.scrollspy({
      target: "#pagenav"
    });

    $("#pagenav").affix({
      offset: 0
    });

    SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.defaults['gutter'] = false;
    SyntaxHighlighter.defaults['smart-tabs'] = false;

    SyntaxHighlighter.all();

    var scrollRefresh = function () {
      body.scrollspy("refresh");
    };
    $(window).on('load', scrollRefresh);
    setTimeout(scrollRefresh, 1000);
  });
</script>